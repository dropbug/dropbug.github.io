[{"categories":["web开发"],"content":"背景 我刚入行的时候是2013年,做企业站.给客户部署时买一台美橙互联的VPS,上去装IIS,SqlServer,.Net Framework,配环境变量,改IIS配置参数,配置数据库账户,权限等等balabala一堆事,这还只是单机应用.OMG!要是配个运维帮我做这些事多好啊!\n后来的Docker瞄准这个痛点,解决了环境不一致和重复性部署的问题.而现在的Serverless更彻底,直接隔离了IT基础设施这一环节,让开发者完全聚焦业务代码.\n应用部署方式演进  物理单机-\u003e虚拟化单机-\u003e虚拟化分布式-\u003eDocker-\u003eKubernetes-\u003eServerless\n 物理单机的时代持续了很多年,后来虚拟化流行起来之后部署方式演进的速度就大大加快了.比如国内Docker刚兴起没多久,k8s又来了,k8s还没玩转,Serverless又来了~扶我起来,我还能学!\n什么是Serverless 阿里云的解释:  函数计算是事件驱动的全托管计算服务。使用函数计算，您无需采购与管理服务器等基础设施，只需编写并上传代码。函数计算为您准备好计算资源，弹性地、可靠地运行任务，并提供日志查询、性能监控和报警等功能. 我的理解:  Serverless是一种无需关心代码运行环境的应用部署方式.开发者只需要提供代码,云服务商来负责部署.\n 为什么要用Serverless 帮助开发者隔离与业务无关的事情,使开发者更加专注.\n传统环境下开发者要关心生成环境的构建,更新,CPU/内存/磁盘/带宽的负载,日志的整理,这些与业务无关的事情分散了不少精力,特别是业务处于增长期的时候.\n而Serverless帮开发者处理了所有这些琐碎的事情,且天生自带负载均衡,按需付费,很适合应对流量波峰波谷差异巨大的场景.\n迁移Egg.js上Serverless 使用阿里云的Serverless服务,“函数计算” 有两种迁移方式,手动上传代码包 or 使用 funcraft自动发布.\n推荐使用funcraft自动发布.\n 使用npm安装funcraft  1  ~ $ npm install @alicloud/fun -g   生成发布配置文件  1  ~ $ fun deploy -y   这一步会在根目录生成一个用于部署的配置文件 template.yaml和应用启动的shell脚本 bootstrap\n配置发布目标参数  1  ~ $ fun config   按照提示，依次配置 Account ID、Access Key Id、Secret Access Key、 Default Region Name Account ID这个不是登录用户名,是阿里云分配的一串数字.id\n执行发布  1  ~ $ fun deploy   选择默认的临时域名,发布成功后阿里云会分配一个临时域名\n访问它就可以看到效果啦\n","description":"","tags":["serverless","egg.js","node.js"],"title":"使用Serverless 部署一个Egg.js应用","uri":"/posts/serverless-eggjs/"},{"categories":null,"content":"一名致力于寻找技术与业务平衡点的全栈工程师.\n编码七年.一年企业软件,六年跨境电商.\n熟悉跨境电商行业,Web开发领域.\n折腾过.Net,Java,现在深爱Node.js的灵活与简单.\n目前灵活就业中,关注新机会.\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":["blog"],"content":"背景介绍 我们可能有各种各样的记录生活与工作的方式,这些记录散落在印象笔记,网易云笔记,手机记事本,石墨文档,CSDN,博客园等等.样式不一,问题不等(格式乱,有广告,界面不清爽,无法传播). 如果你也面临这样的问题,来试试免费的快速的个人博客吧.\nGitpage是什么 Github提供的免费静态站点空间\nHugo是什么 官方:\n Hugo is the world’s fastest static website engine.\n Hugo是一个静态站点生成工具,使用GO编写.从Markdown生成网页的速度非常快.\n安装Hugo很简单,略过.\n新建Hugo site 1  ~ $ hugo new site myBlog #myBlog是自定义的站点名称,你可以自己取   这一步会初始化一个空的Hugo站点,要写文章,在myBlog/content/posts下面新建一个MD文件就好了.推荐使用命令\n1  ~ $ hugo new \"posts/hello-world.md\"    hugo new 生成的MD文档头部有draft: true的标识,当为false时才会打包进静态文件.\n 为文章指定tags和categories 设置tags和categories可以检索和统计文章. Hugo默认支持这两种标记.可以在根目录的config.toml(也可能是json,yaml后缀)找到Taxonomies的节 默认就叫tags,categories\n为了方便各个终端都可以写文章,我们把这个站点传到Github去.\n先初始化,然后设置远程仓库\n1 2  ~ $ git init ~ $ git remote add origin ***.git   配置gitignore 先初始化,然后设置远程仓库\n1  ~ $ vi .gitignore   写入 public,这个目录是Hugo生成的静态站点文件,仅用于部署,不适合放在这个仓库里,所以忽略掉.\n提交更改,推送到远程仓库\n1 2 3  ~ $ git add . ~ $ git commmit -m \"init\" ~ $ git push   启动站点\n1  ~ $ hugo server -D #浏览器中打开 localhost:1313 就可以看到效果了.   安装一个主题 默认的样式比较简陋,可以安装主题来改变站点的风格.\nmeme是这个主题的名字,这一步从github下载了meme这个主题包到 themes/meme目录,并且将该目录设置为了Git子目录.\n1  ~ $ git submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme   复制主题的示例配置文件到根目录\n1  ~ $ rm config.toml \u0026\u0026 cp themes/meme/config-examples/en/config.toml config.toml   再打开看看效果吧\n1  ~ $ hugo server -D #浏览器中打开 localhost:1313 就可以看到效果了.   发布到Gitpage  到Github新建一个仓库,名字叫 dropbug.github.io  dropbug是我在Github的名字,你应该替换为你的.仓库权限必须为public.\nHugo生成的静态站点文件都在/public目录下,我们只需要把这些文件传到 ***.github.io这个仓库即可.\n配置public目录与远程仓库的关联 先清理public目录  1  ~ $ rm -r public #删除目录   配置关联\n1  ~ $ git submodule add -f --depth 1 https://github.com/dropbug/dropbug.github.io.git public   https://github.com/dropbug/dropbug.github.io.git是我的静态博客站点的远程仓库地址,你应该替换为你的.\n发布博客  1 2 3 4 5  ~ $ hugo -t meme #生成静态文件,meme是主题名. ~ $ cd public ~ $ git add . ~ $ git commit -m \"一次新发布\" ~ $ git push   打开 dropbug.github.io就可以看到博客啦.\n配置自定义域名 参考官方\n一键部署脚本 在根目录新建 deploy.sh,写入以下内容.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #!/bin/bash # 部署到 github pages 脚本 # 错误时终止脚本 set -e # Add changes to git. git add . # Commit changes. msg=\"building site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" git push # 打包。even 是主题 hugo -t meme # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` cd public # Add changes to git. git add . # Commit changes. git commit -m \"$msg\" git push cd ../   发布时在根目录执行就好了\n1  ~ $ . deploy.sh #一键发布脚本   ","description":"","tags":["hugo","go","gitpage","blog"],"title":"Hugo+Gitpage搭建个人博客","uri":"/posts/blog-hugo-gitpage/"},{"categories":null,"content":"从0设计一个CRM客服系统 项目介绍 跨境电商防关联客服系统,客服人员无需登录各个平台各个店铺,只要登录一个客服系统就可以回复所有邮件.\n项目规模 日活50万,QPS峰值10万.\n架构设计思考过程 业务本身并不复杂,一句话就就可以说清楚. 系统从平台拉邮件回来,展示给用户,用户回复后通过API提交给各个平台.\n业务流程图 抽象业务对象 这里忽略了公司,平台这些不是很核心的对象.\n 用户 店铺 邮件 回复  服务拆分  ApiProxyServer-负责与电商平台的API交互. TaskServer-负责管理定时任务,生产消息. UserServer-接收客户端的请求.  数据库设计 先看数据量 日活50万,每个用户3个店铺,每个店铺平均2封邮件,一个月新产生的邮件数据:5032*30(天)=900万.一年之后仅邮件数据本身已经到一亿量级.为避免单表数据量过大,我们对邮件表按照月份进行分表,邮件在平台上的创建时间为分区键,取年份+月份做为表名.\n邮件一般都是要回复的,那回复表的数量至少与邮件表量级相等,只多不少.回复表也需要做分表.\n这个项目的场景中,日活用户就是付费了的客户,至少有一台云服务器在运行,非活跃用户我们不用考虑他们的负载.所以用户表和店铺表数据量都不大,一两百万的级别,不需要分表.\nMongoDB横向拓展方便,查询性能比Mysql高,自带副本集,我们选择它做存储.\n性能瓶颈预估 可能发生的性能瓶颈\n 拉邮件是全店铺固定时间周期或少量用户手动触发,假设150万店铺,拉取频率是5分钟拉.这个写并发有可能是比较高的.也有可能很低,因为来邮件的时间是看客户的,可能比较分散.瓶颈预估:写并发1万. 查看邮件的高峰在每天刚开始上班的时间段最高,可能集中在8:30-10:30.其他时间应该比较平缓稳定.数据访问存在明显热点区域,近24小时未回复的热点较高,最后回复时间超过一周的几乎没有访问.瓶颈预估:读并发10万 回复邮件是客服人员一个个点开写回复的,速度较慢,并发比查询的峰值要低,我们假设是5万并发,好消息是用户对回复的实时反馈要求不高,点击回复按钮后是1秒提交到平台还是60秒提交到平台,对用户来说不是很关心.瓶颈预估:写并发5万  解决方案\n  TaskServer从MongoDB拉取全量店铺ID存储在本地文件(店铺数据更新不频繁,量也不大,放本地即可),定期读取文件,生成消息(Topic:PullEmail),通知各个ApiProxyServer拉取邮件. 各个ApiProxyServer从MachineShopMap拉取各自店铺ID,通过店铺拉取消息(Topic:PullEmail),通过API去各个电商平台拉邮件,接收到邮件后序列化(Json)插入到消息队列(Topic:ReadyEmail). TaskServer从消息队列(Topic:ReadyEmail)取出邮件,开N个线程(最多能开多少看DB的性能),并发插入.这里我们是5分钟一波,一波1万条.10000/3600=2.7条/s;所以这里N=3.压力不大.\n  未回复的邮件全放到Redis. 一封邮件有标题(100个字符),内容(600个字符),发件人(50个字符),产品ID(20个字符),创建时间(24个字符),794个字符,一天300万封邮件,峰值大约是2.2GB,邮件一旦被回复后就从Redis中剔出去,实际存储量比这个要小. 这里还应该关注响应时间,用户等待时间不应该超过1秒.所以这里我们后端部署多个UserServer承接客户端请求,中间由Nginx做轮询式负载均衡,前端纯静态架在Nginx.\n  各个UserServer接到请求后插入消息队列(Topic:SaveReply),TaskServer从消息队列(Topic:SaveReply)取出回复,开N个线程(最多能开多少看DB的性能),并发插入回复表.客户最多忍受\n  ","description":"","tags":null,"title":"天空中的小溪-王晓熙的个人博客","uri":"/posts/test/"}]
